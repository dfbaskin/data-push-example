using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace RecordProxy.Generator;

[Generator]
public class RecordProxyGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // if(!System.Diagnostics.Debugger.IsAttached) {
        //     System.Diagnostics.Debugger.Launch();
        // }

        IncrementalValuesProvider<RecordDeclarationSyntax> toGenerate =
            context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsGenerateProxyCandidate(s),
                    transform: static (ctx, _) => HasGenerateProxyMarkerAttribute(ctx)
                )
                .Where(static m => m is not null)!;

        var compilation = context.CompilationProvider.Combine(toGenerate.Collect());

        context.RegisterSourceOutput(
            compilation,
            static (spc, source) => Execute(source.Left, source.Right, spc)
        );
    }

    static bool IsGenerateProxyCandidate(SyntaxNode node) =>
        node is RecordDeclarationSyntax { AttributeLists.Count: > 0 };

    const string AttributeName = "RecordProxy.Generator.GenerateProxyAttribute";

    static RecordDeclarationSyntax? HasGenerateProxyMarkerAttribute(GeneratorSyntaxContext context)
    {
        var recordSyntax = (RecordDeclarationSyntax)context.Node;

        foreach (var attrListSyntax in recordSyntax.AttributeLists)
        {
            foreach (var attrSyntax in attrListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attrSyntax).Symbol is not IMethodSymbol attrSymbol)
                {
                    continue;
                }

                var attrName = attrSymbol.ContainingType.ToDisplayString();
                if (attrName == AttributeName)
                {
                    return recordSyntax;
                }
            }
        }

        return null;
    }

    static void Execute(
        Compilation compilation,
        ImmutableArray<RecordDeclarationSyntax> records,
        SourceProductionContext spc
    )
    {
        if (!records.IsDefaultOrEmpty)
        {
            foreach(var record in records)
            {
                Generate(compilation, record, spc);
            }
        }
    }

    static void Generate(
        Compilation compilation,
        RecordDeclarationSyntax record,
        SourceProductionContext spc
    )
    {
        var model = compilation.GetSemanticModel(record.SyntaxTree);
        if (model.GetDeclaredSymbol(record) is not INamedTypeSymbol namedTypeSymbol)
        {
            return;
        }

        var recordName = namedTypeSymbol.ToString();
        var segments = recordName.Split('.').ToList();
        var baseName = segments.Last();
        var namespaceName = string.Join(".", segments.Take(segments.Count - 1));
        var proxyName = $"{baseName}Proxy";
        var fileName = $"{proxyName}.g.cs";

        var members = namedTypeSymbol.GetMembers()
            .Where(m => m.Kind == SymbolKind.Property && !m.IsImplicitlyDeclared)
            .Cast<IPropertySymbol>()
            .ToList();

        var lastMember = members.Last();
        bool IsLastMember(IPropertySymbol member)
        {
            return member.Equals(lastMember, SymbolEqualityComparer.Default);
        }

        var sb = new StringBuilder();
        void Add(string text)
        {
            text.Split('\n')
                .Where(line => !string.IsNullOrWhiteSpace(line))
                .Select(line => line.TrimEnd())
                .ToList()
                .ForEach(line => sb.AppendLine(line));
        };

        Add("");
        Add($@"
// <auto-generated/>
#nullable enable

using RecordProxy.Generator;

");
        if (!string.IsNullOrWhiteSpace(namespaceName))
        {
            Add($"namespace {namespaceName};");
        }
        Add($@"

public record {proxyName} : {baseName}
{{
    private ChangeCollectorState state;
");

        members.ForEach(member =>
            GenerateProperty(
                PropertyGenerateType.Property,
                member,
                Add,
                IsLastMember(member)
            ));
        Add($@"
    public {proxyName}(
        {baseName} other,
        ChangeCollectorState state
    ) : base(
");
        members.ForEach(member =>
            GenerateProperty(
                PropertyGenerateType.SetClonedValue,
                member,
                Add,
                IsLastMember(member)
            ));
        Add($@"
    )
    {{
        this.state = state;
    }}

    public {baseName} Unwrap() =>
        new {baseName}(
");
        members.ForEach(member =>
            GenerateProperty(
                PropertyGenerateType.SetProxyValue,
                member,
                Add,
                IsLastMember(member)
            ));
        Add($@"
        );

    public static {baseName} Capture(
        {baseName} model,
        ChangeCollectorState state,
        Func<{proxyName}, {proxyName}> modifyFn
    )
    {{
        var proxy = Wrapper.Wrap(model, state);
        proxy = modifyFn(proxy);
        return Wrapper.UnWrap(proxy);
    }}

    public static IProxyWrapper<{baseName}, {proxyName}> Wrapper {{ get; }}
        = new WrapperImpl();

    private class WrapperImpl : IProxyWrapper<{baseName}, {proxyName}>
    {{
        public {proxyName} Wrap({baseName} model, ChangeCollectorState state)
            => new {proxyName}(model, state);

        public {baseName} UnWrap({proxyName} proxy)
            => proxy.Unwrap();
    }}
}}

public static class {proxyName}Extensions
{{
    public static {baseName} Capture(
        this {baseName} model,
        IChangeCollector collector,
        Func<{proxyName}, {proxyName}> modifyFn
    ) => {proxyName}.Capture(model, new ChangeCollectorState(collector), modifyFn);
}}
");
        spc.AddSource(fileName, sb.ToString());
    }

    private enum PropertyGenerateType
    {
        Property,
        SetClonedValue,
        SetProxyValue
    }

    static void GenerateProperty(
        PropertyGenerateType genType,
        IPropertySymbol prop,
        Action<string> add,
        bool isLastProp
    )
    {
        var name = prop.Name;
        var suffix = isLastProp ? "" : ",";

        if(genType == PropertyGenerateType.Property)
        {
            if (IsCollectionType(prop.Type))
            {
                var modelType = ((INamedTypeSymbol)prop.Type)
                    .TypeArguments
                    .Select(t => t.Name)
                    .First();
                var arrayType = $"RecordArrayProxy<{modelType}, {modelType}Proxy>";
                var arrayName = $"{name}ArrayProxy";
                add($@"
    private {arrayType}? {arrayName} = null;
    private {arrayType} Get{arrayName}()
        => {arrayName} ?? ({arrayName} = new {arrayType}(
                state.AddPath(nameof({name})),
                {modelType}Proxy.Wrapper,
                base.{name}
            ));
    public new {arrayType} {name}
    {{
        get => Get{arrayName}();
        init
        {{
            {arrayName} = value;
            base.{name} = value.ToCollection(value);
        }}
    }}
");
            }
            else if (prop.Type.IsRecord)
            {
                var proxyType = $"{prop.Type}Proxy";
                var proxyName = $"{name}Proxy";
                add($@"
    private {proxyType}? {proxyName} = null;
    private {proxyType} Get{name}Proxy()
        => {proxyName} ?? (new {proxyType}(
                base.{name},
                state.AddPath(nameof({name}))
            ));
    public new {proxyType} {name}
    {{
        get => Get{name}Proxy();
        init
        {{
            {proxyName} = value;
            base.{name} = value;
        }}
    }}
");
            }
            else
            {
                add($@"
    public new {prop.Type} {name}
    {{
        get => base.{name};
        init
        {{
            base.{name} = state.Handler.ReplaceIfChanged(
                state.ModelPath.AddPath(nameof({name})),
                base.{name},
                value
            );
        }}
    }}
");
            }
        }
        else if(genType == PropertyGenerateType.SetClonedValue)
        {
            add($@"        {name}: other.{name}{suffix}");
        }
        else if(genType == PropertyGenerateType.SetProxyValue)
        {
            if (IsCollectionType(prop.Type))
            {
                add($@"            {name}: this.{name}.ToCollection(){suffix}");
            }
            else if(prop.Type.IsRecord)
            {
                add($@"            {name}: this.{name}.Unwrap(){suffix}");
            }
            else
            {
                add($@"            {name}: this.{name}{suffix}");
            }
        }
    }

    public static bool IsCollectionType(ITypeSymbol symbol)
        => symbol.AllInterfaces
            .Select(i => (I: i, S: (ISymbol)i))
            .Where(t =>
            {
                return
                    t.I.IsGenericType &&
                    t.S.MetadataName == "IEnumerable`1" &&
                    t.I.TypeArguments.Any(t => t.IsRecord);
            })
            .Any();
}
